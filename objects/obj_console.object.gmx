<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Console

// Configuration
con_key = vk_f12; // The key for toggling the console
con_visible = false; // Hidden by default
con_sep = ";"; // Seperator for command and arguments
con_admin = true; // Whether user can execute admin commands
autoexec = true; // Perform commands in local 'autoexec.cfg' script.
con_dim = 0.5; // How much to dim background when console visible.

con_sug_enabled = true; // Display command suggestions
con_sug_margin = 0; // Margin between textbox and suggestions
con_sug_limit = 10; // Maximum number of suggestions to show
con_sug_pad = 8; // Padding for suggestions box
con_sug_bg_c = c_white; // Suggestions background color
con_sug_sel_c = make_color_rgb(234, 236, 239); // Highlighted suggestion background color
con_sug_cmd_c = c_black; // Suggested command text color
con_sug_arg_c = c_gray; // Suggested argument text color
con_sug_typ_c = make_color_rgb(152, 188, 249); // Suggested argument type text color

// Init
con_cmds = ds_list_create(); // Holds all declared commands
con_sug = ds_list_create(); // Holds suggested commands
con_cmd_last = ""; // Last command entered
con_sug_sel = -1; // Highlighted suggestion
con_surf = noone; // Background surface for console
if autoexec then alarm[0] = 10; // Auto execute
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Textbox

// Features
history_enabled = true; // Undo / Redo enabled?
clipboard_enabled = true; // Cut/Copy/Paste enabled?

// Attributes
active = true; // Whether input field is active
value = ""; // The textbox value
maxlength = 100; // Max number of characters
gui = false; // Draw in GUI event

// Font
fnt = fnt_open_sans_16; // Font
fnt_c = c_black; // Font color
fnt_a = 1; // Font alpha

// Textbox Appearance
textbox_x = 20; // X position for textbox
textbox_y = 20; // Y position for textbox

fill_c = c_white; // Background color
fill_a = 1; // Background alpha

border_c = c_white; // Border color
border_a = 1; // Border alpha
border_w = 1; // Border width

active_c = c_white; // Active border color
active_a = 1; // Active border alpha
active_w = 2; // Active border width

// Highlighting
select_bg_c = c_black; // Highlighted bg color
select_bg_a = 1; // Highlighted bg alpha
select_fnt_c = c_white; // Highlighted text color
select_fnt_a = 1; // Highlighted text alpha

// Dimensions
draw_set_font(fnt); // Font size
padding = 8; // Text padding
width = 600; // Textbox width
height = string_height("Wp")+(padding*2); // Textbox height

// Cursor
cursor_c = c_black; // Cursor color
cursor_a = 1; // Cursor alpha
cursor_w = 2; // Cursor width

cursor_flash_sp = 24; // Cursor flash speed
cursor_flash_alarm = cursor_flash_sp; // Reset flash timer
cursor_flash = 0; // Cursor visible
cursor_pos1 = string_length(value); // First cursor position
cursor_pos2 = string_length(value); // Second cursor position
cursor_drag = false; // Cursor can drag

// Double clicking
db_delay = 20; // Time distance between clicks
db_timer = -1; // Timer
db_click_x = mouse_x; // Double click X position

// Scrolling
scroll = 0; // Current scroll level
scroll_max = 0; // Max scroll level

// Undo / Redo
undo = ds_stack_create(); // Undo list
redo = ds_stack_create(); // Redo list
ds_stack_push(undo,value);

// Surface
surf = surface_create(width-(padding*2), height-(padding*2));
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Commands

/*
All commands should be declared here using the
console_add() script. Commands are executed in
the User Defined 0 event.
*/

console_add("sq_size",false,"size","real");
console_add("sq_color",false,"red,green,blue","real,real,real");
console_add("sq_speed",false,"xspeed","real");
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Clearup

// Destroy history stacks
ds_stack_destroy(undo);
ds_stack_destroy(redo);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Auto Execute

/*
AUTOEXEC
This automatically executes commands in the
autoexec.txt file.
*/

// Look for autoexec.txt
if (file_exists("autoexec.txt")) {

    // Read file
    var file = file_text_open_read("autoexec.txt");
    
    // For each line
    while (!file_text_eof(file)) {
    
        // Command &amp; arguments
        value = file_text_readln(file);
        command = string_copy(value,1,string_pos(con_sep,value)-1);
        if (command != "") {
            value = string_delete(value,1,string_pos(con_sep,value));
            arg = string_explode_array(value,con_sep);
        } else {
            command = value;
            arg = undefined;
        }
        
        // Validate and execute
        event_perform(ev_other,ev_user4);
    
    }
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Activation

// Toggle console
if (keyboard_check_pressed(con_key)) {
    if (con_visible) then event_perform(ev_other,ev_user2);
    else event_perform(ev_other,ev_user1);
}

// Abort if console not active
if !con_visible then exit;

// Update surface
if !surface_exists(surf) {

    surf = surface_create(width-(padding*2), height-(padding*2));
    
}

// Activate
if (mouse_area_pressed(x,y,x+width,y+height,mb_left)) {
    
    // Single or double click?
    if (db_timer = -1) {
    
        // Single click
        db_timer = db_delay;
        db_click_x = mouse_x;
    
    } else {
    
        // Double click
        var pos = string_find_word_endpoints(value, cursor_pos1);
        cursor_pos1 = pos[0];
        cursor_pos2 = pos[1];
        
        // No drag
        cursor_drag = false;
        
        // Reset
        db_timer = -1;
        
    }
    
} else {

    // Deactivate
    if (mouse_check_button_pressed(mb_left)) {
    
        // Deactivate event
        event_perform(ev_other,ev_user2);
    
    }

}

// Highlighting
if (cursor_drag &amp;&amp; mouse_check_button_pressed(mb_left)) {

    cursor_pos2 = string_find_position_x(value, x+padding, mouse_x+scroll, 0);

} else cursor_drag = false;

// Update double click timer
if (db_timer &gt; -1) then db_timer --;
if (db_click_x != mouse_x) then db_timer = -1;

// Update cursor
cursor_flash_alarm --;

if (cursor_flash_alarm = 0) {

    cursor_flash = !cursor_flash;
    cursor_flash_alarm = cursor_flash_sp;

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Keyboard

// Detect highlighting
var sel = (cursor_pos1 != cursor_pos2);

// If textbox active
if (active) {

    // Check pressed key valid
    if (keyboard_lastkey != -1 &amp;&amp;
    keyboard_lastkey != vk_enter &amp;&amp;
    keyboard_lastkey != ord("#")) {
    
        // Check CTRL or Shift key pressed
        var modkey = keyboard_check(vk_shift)-keyboard_check(vk_control);
        
        if (!keyboard_check(vk_shift) &amp;&amp;
        !keyboard_check(vk_control)) then modkey = -2;
        
        // Find which key pressed
        switch (keyboard_lastkey) {
        
            // Home
            case vk_home:
            
                    // Send cursor to start
                    cursor_pos1 = 0;
                    cursor_pos2 = cursor_pos;
                   
                    // Reset cursor flash
                    cursor_flash_alarm = cursor_flash_sp;
                    cursor_flash = 1;
            
                break;
                
            // End
            case vk_end:
            
                    // Send cursor to end of string
                    cursor_pos1 = string_length(value);
                    cursor_pos2 = cursor_pos;
    
                    // Reset cursor flash
                    cursor_flash_alarm = cursor_flash_sp;
                    cursor_flash = 1;
            
                break;
                
            // Left arrow
            case vk_left:
                    
                    // If highlighted and no modifier key pressed
                    if (sel &amp;&amp; modkey = -2) {
                    
                        var minpos = min(cursor_pos1,cursor_pos2);
                        cursor_pos1 = minpos;
                        cursor_pos2 = minpos;
                    
                    } else {
                    
                        // One space or to start of word?
                        if (modkey = -1) {
                        
                            var pos = string_find_word_endpoints(value, cursor_pos1);
                            var newpos = pos[0];
                        
                        } else {
                        
                            var newpos = clamp(cursor_pos2-1, 0, string_length(value));
                        
                        }
                        
                        // Move cursor
                        cursor_pos2 = newpos;
                        if (modkey != 1) {
                            cursor_pos1 = cursor_pos2;
                        }
                    
                    }
                    
                    // Reset flashing
                    cursor_flash_alarm = cursor_flash_sp;
                    cursor_flash = 1;
            
                break;
                
            // Right arrow
            case vk_right:
                    
                    // If highlighted and no modifier key pressed
                    if (sel &amp;&amp; modkey = -2) {
                    
                        var maxpos = max(cursor_pos1,cursor_pos2);
                        cursor_pos1 = maxpos;
                        cursor_pos2 = maxpos;
                        
                    } else {
                    
                        // One space or to end of word?
                        if (modkey = -1) {
                        
                            var pos = string_find_word_endpoints(value, cursor_pos1);
                            var newpos = pos[1];
                        
                        } else {
                        
                            var newpos = clamp(cursor_pos2+1, 0, string_length(value));
                        
                        }
                        
                        // Move cursor
                        cursor_pos2 = newpos;
                        if (modkey != 1) {
                        
                            cursor_pos1 = cursor_pos2;
                            
                        }
                    
                    }
                    
                    // Reset flashing
                    cursor_flash_alarm = cursor_flash_sp;
                    cursor_flash = 1;
            
                break;
                
            // Backspace
            case vk_backspace:
            
                    // Delete highlighted text
                    if (sel) {
                    
                        event_perform(ev_other,ev_user3);
                        
                    } else {
                    
                        if (modkey = -1) {
                        
                            // Find start of word
                            var pos = string_find_word_endpoints(value, cursor_pos2);
                            
                            // Delete word
                            value = string_delete(value, pos[0], cursor_pos2-pos[0]);
                            cursor_pos1 = pos[0];
                            cursor_pos2 = cursor_pos1;
                        
                        } else {
                        
                            // Delete single character
                            value = string_delete(value, cursor_pos1, 1);
                            cursor_pos1 -= 1;
                            cursor_pos2 = cursor_pos1;
                            
                        }
                    
                    }
                    
                    // Reset flashing
                    cursor_flash_alarm = cursor_flash_sp;
                    cursor_flash = 1;
                    
                    // History
                    if (history_enabled) {
                    
                        ds_stack_push(undo,value);
                        ds_stack_clear(redo);
                    
                    }
            
                break;
              
            // Delete  
            case vk_delete:
            
                    // Delete highlighted text
                    if (sel) {
                    
                        event_perform(ev_other,ev_user3);
                        
                    } else {
                    
                        if (modkey = -1) {
                        
                            // End of word
                            var pos = string_find_word_endpoints(value, cursor_pos2);
                            
                            // Delete word
                            value = string_delete(value, cursor_pos2, pos[1]-cursor_pos2);
                            cursor_pos1 = pos[1];
                            cursor_pos2 = cursor_pos1;
                        
                        } else {
                        
                            // Delete single character
                            value = string_delete(value, cursor_pos1+1, 1);
                        
                        }
                    
                    }
                    
                    // Reset
                    cursor_flash_alarm = cursor_flash_sp;
                    cursor_flash = 1;
                    chk = 1;
                    
                    // History
                    if (history_enabled) {
                    
                        ds_stack_push(undo, value);
                        ds_stack_clear(redo);
                    
                    }
            
                break;
                
            // Character keys
            default:
            
                    // Check
                    var chk = 0;
                    
                    // Shortcut keys
                    if (modkey = -1) {
                    
                        // Select all
                        if (keyboard_lastkey = ord("A")) {
                        
                            // Highlight text
                            cursor_pos1 = 0;
                            cursor_pos2 = string_length(value);
                            
                            // History
                            if (history_enabled) {
                            
                                ds_stack_push(undo,value);
                                ds_stack_clear(redo);
                            
                            }
                            
                            // Checked
                            chk = 1;
                        
                        }
                        
                        // Clipboard functions
                        if (clipboard_enabled) {
                        
                            // Copy
                            if (keyboard_lastkey = ord("C")) {
                            
                                // If text highlighted
                                if (sel) {
                                
                                    // Add to clipboard
                                    var minpos = min(cursor_pos1, cursor_pos2);
                                    var maxpos = max(cursor_pos1, cursor_pos2);
                                    var seltxt = string_copy(value, minpos+1, maxpos-minpos);
                                    clipboard_set_text(seltxt);
                                
                                }
                                
                                // Reset flashing
                                cursor_flash_alarm = cursor_flash_sp;
                                cursor_flash = 1;
                                
                                // Checked
                                chk = 1;
                            
                            }
                            
                            // Paste
                            if (keyboard_lastkey = ord("V")) {
                            
                                // If clipboard holds text
                                if (clipboard_has_text()) {
                                
                                    // If text highlighted then replace
                                    if (sel) {
                                    
                                        event_perform(ev_other,ev_user3);
                                    
                                    }
                                    
                                    // Add text from clipboard
                                    var clptxt = clipboard_get_text();
                                    value = string_insert(clptxt, value, cursor_pos1+1);
                                    cursor_pos1 += string_length(clptxt);
                                    cursor_pos2 = cursor_pos1;
                                    
                                    // History
                                    if (history_enabled) {
                                        
                                        ds_stack_push(undo,value);
                                        ds_stack_clear(redo);
                                    
                                    }
                                    
                                    // Reset flashing
                                    cursor_flash_alarm = cursor_flash_sp;
                                    cursor_flash = 1;
                                    
                                    // Checked
                                    chk = 1;
                                
                                }
                            
                            }
                            
                            // Cut
                            if (keyboard_lastkey = ord("X")) {
                            
                                // If text is highlighted
                                if (sel) {
                                
                                    // Add to clipboard
                                    var minpos = min(cursor_pos1, cursor_pos2);
                                    var maxpos = max(cursor_pos1, cursor_pos2);
                                    var seltxt = string_copy(value, minpos+1, maxpos-minpos);
                                    clipboard_set_text(seltxt);
                                    
                                    // Delete highlighted
                                    event_perform(ev_other,ev_user3);
                                    
                                    // History
                                    if (history_enabled) {
                                        
                                        ds_stack_push(undo,value);
                                        ds_stack_clear(redo);
                                    
                                    }
                                    
                                    // Reset flashing
                                    cursor_flash_alarm = cursor_flash_sp;
                                    cursor_flash = 1;
                                    
                                    // Checked
                                    chk = 1;
                                
                                }
                            
                            }
                        
                        } else if !history_enabled then exit; // Clipboard
                        
                        // History
                        if (history_enabled) {
                        
                            // Undo
                            if (keyboard_lastkey = ord("Z")) {
                            
                                // If there is enough history
                                if (ds_stack_size(undo) &gt; 1) {
                                
                                    // Update history
                                    var t1 = ds_stack_top(undo);
                                    ds_stack_push(redo, t1);
                                    
                                    ds_stack_pop(undo);
                                    t2 = ds_stack_top(undo);
                                    
                                    // Use value from history
                                    value = t2;
                                    
                                    // Reset flashing
                                    cursor_flash_alarm = cursor_flash_sp;
                                    cursor_flash = 1;
                                    
                                    // Checked
                                    chk = 1;
                                
                                }
                            
                            }
                            
                            // Redo
                            if (keyboard_lastkey = ord("Y")) {
                            
                                // If there is enough history
                                if (ds_stack_size(redo) &gt; 1) {
                                
                                    // Update history
                                    var t = ds_stack_pop(redo);
                                    ds_stack_push(undo, t);
                                    
                                    // Set text
                                    value = t;
                                    
                                    // Checked
                                    chk = 1;
                                
                                }
                            
                            }
                            
                        } else exit; // History
                        
                    } // Shortcut keys
                    
                    // Typing
                    if (chk != 1) {
                    
                        // If there is text to place
                        if (string_length(keyboard_lastchar) != 0) {
                        
                            // Delete if highlighted
                            if (sel) then event_perform(ev_other,ev_user3);
                            
                            // Add last pressed character
                            value = string_insert(keyboard_lastchar, value, cursor_pos1+1);
                            cursor_pos1 += 1;
                            cursor_pos2 = cursor_pos1;
                            
                            // History
                            if (history_enabled) {
                                ds_stack_push(undo,value);
                                ds_stack_clear(redo);
                            }
                            
                            // Reset cursor
                            cursor_flash_alarm = cursor_flash_sp;
                            cursor_flash = 1;
                        
                        }
                    
                    }
            
                break;
        
        } // Keyboard lastchar
        
        // Reset for next step
        keyboard_lastkey = -1;
        keyboard_lastchar = "";
    
    }

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Scrolling

var txtw = string_width(value); // String width
var boxw = (width-(padding*2)); // Box width

// If string wider than text box
if (txtw &gt; boxw) {

    scroll_max = txtw - boxw;

} else {

    scroll_max = 0;
    scroll = 0;

}

// Scroll along with selection
if (scroll_max != 0) {

    // Get X of secondary cursor
    var curx = (x+padding)+string_width(string_copy(value, 0, cursor_pos2))-scroll;
    
    // Text bounding box size
    var x1 = x + padding;
    var x2 = (x + width) - padding;
    
    // Scroll left
    if (curx &lt; x1) then scroll -= x1-curx;
    
    // Scroll right
    if (curx &gt; x2) then scroll += curx-x2;
    
    // Limit scrolling
    scroll = clamp(scroll, 0, scroll_max);
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Error Checking

//remove any new lines
    value = string_replace_all(value, "
", "");
value = string_replace_all(value, "#", "");
value = string_replace_all(value, chr(13)+chr(10), "");
value = string_replace_all(value, chr(13), "");
value = string_replace_all(value, chr(15), "");
value = string_replace_all(value, chr(10), "");

//correct cursor
cursor_pos1 = clamp(cursor_pos1, 0, string_length(value)); 
cursor_pos2 = clamp(cursor_pos2, 0, string_length(value));

// Clear history if too much
if (history_enabled) {

    if ((ds_stack_size(undo) &gt; 30) || 
    (ds_stack_size(redo) &gt; 30)) {
    
        ds_stack_clear(undo);
        ds_stack_clear(redo);
        ds_stack_push(undo, value);
        
    }
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Console

// User begins typing
if keyboard_check_pressed(vk_anykey) &amp;&amp;
!keyboard_check_pressed(vk_down) &amp;&amp;
!keyboard_check_pressed(vk_right) &amp;&amp;
string_count(con_sep,value) == 0 {

    // If something entered
    if (string_length(value) &gt; 0) {

        // Clear suggestions list
        ds_list_clear(con_sug);
        
        // For each declared command
        for (var i=0; i&lt;ds_list_size(con_cmds); i+=4) {
        
            // If user has permission to execute
            if (!con_cmds[| i+1]) || (con_cmds[| i+1] &amp;&amp; con_admin) {
            
                // Get command
                var cmd = con_cmds[| i];
                
                // Check input matches command
                if string_copy(cmd,1,string_length(value)) == value {
                
                    // Add to suggestions list
                    ds_list_add(con_sug,i);
                
                }
            
            }
        
        }
        
    } else {
    
        // Clear suggestions list
        ds_list_clear(con_sug);
    
    }

}

// Scroll through suggestions
if (keyboard_check_pressed(vk_down) &amp;&amp;
ds_list_size(con_sug) &gt; 0) {

    if (con_sug_sel &lt; ds_list_size(con_sug)-1)
    then con_sug_sel ++ else con_sug_sel = 0;

}

// Select suggestion
if (keyboard_check_pressed(vk_right) &amp;&amp;
con_sug_sel &gt; -1) {

    value = con_cmds[| con_sug[| con_sug_sel]];
    cursor_pos1 += string_length(value);
    cursor_pos2 = cursor_pos1;

}

// Last command
if (keyboard_check_pressed(vk_up) &amp;&amp;
con_cmd_last != "") {

    value = con_cmd_last;
    cursor_pos1 += string_length(value);
    cursor_pos2 = cursor_pos1;

}

// If command submitted
if (keyboard_check_pressed(vk_enter)) {
    
    // Input
    command = string_copy(value,1,string_pos(con_sep,value)-1);
    if (command != "") {
        value = string_delete(value,1,string_pos(con_sep,value));
        arg = string_explode_array(value,con_sep);
    } else {
        command = value;
        arg = undefined;
    }
    
    // Validate and execute
    event_perform(ev_other,ev_user4);

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Validate

// Validation
var index = ds_list_find_index(con_cmds,command);
var admin = con_cmds[| index+1];
var args = con_cmds[| index+2];
var typs = con_cmds[| index+3];

// Deactivate console
event_perform(ev_other,ev_user2);

// If command declared
if (index != -1) {

    // If there are arguments
    if (is_array(arg)) {
    
        // Check correct type of arguments
        if (array_length_1d(arg) != array_length_1d(args)) {
            show_debug_message("[CONSOLE] Not correct number of arguments for '"+command+"'");
            exit;
        }
        
        // Check type
        if (is_array(typs)) {
        
            // For each argument
            for(var a=0; a&lt;array_length_1d(arg); a++) {
            
                // Type
                switch(typs[a]) {
                
                    case "real": case "int": case "float":
                            if (!is_real(arg[a])) {
                                show_debug_message("[CONSOLE] '"+command+"["+arg[a]+"]' needs to be a real value.");
                                exit;
                            }
                        break;
                        
                    case "string":
                            if (!is_string(arg[a])) {
                                show_debug_message("[CONSOLE] '"+command+"["+arg[a]+"]' needs to be a string.");
                                exit;
                            }
                        break;
                
                }
            
            }
        
        }
        
    
    } else
    
    // If arguments expected and none sent
    if (is_array(args)) {
    
        show_debug_message("[CONSOLE] '"+command+"' expects arguments.");
        exit;
    
    }
    
    // Execute command
    show_debug_message("[CONSOLE] Executed command: "+command);
    event_perform(ev_other,ev_user0);
    con_cmd_last = command;
    
} else {

    show_debug_message("[CONSOLE] Unknown command.");

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Delete selection

if (cursor_pos1 != cursor_pos2) {
    
    var minpos, maxpos;
    minpos = min(cursor_pos1, cursor_pos2);
    maxpos = max(cursor_pos1, cursor_pos2);
    value = string_delete(value, minpos+1, maxpos-minpos);
    cursor_pos1 = minpos;
    cursor_pos2 = minpos;
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Deactivate

// Free up background surface
surface_free(con_surf);

// Deactivate console
con_visible = false;

// Clearup
value = "";
con_sug_sel = 0;
ds_list_clear(con_sug);

// Reactivate instances
instance_activate_all();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Activate

// Create background
var sw = surface_get_width(application_surface);
var sh = surface_get_height(application_surface);
con_surf = surface_create(sw,sh);
surface_copy(con_surf,0,0,application_surface);

// Deactivate everything
instance_deactivate_all(true);
    
// Reset
keyboard_lastkey = -1;
keyboard_lastchar = "";

// Reposition text cursor
cursor_drag = true;
cursor_pos1 = string_find_position_x(value, x+padding, mouse_x+scroll, 0);
cursor_pos2 = cursor_pos1;

// Reset flashing
cursor_flash_alarm = cursor_flash_sp;
cursor_flash = 1;

// Show console
con_visible = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Execute command

/*
Here is where the command is executed. The command 
is stored in the 'command' variable, and arguments 
are stored in the 'arg' array.
*/

switch(command) {

    case "sq_size":
            obj_demo.sq_size = arg[0];
        break;
        
    case "sq_color":
            obj_demo.sq_color = make_color_rgb(arg[0],arg[1],arg[2]);
        break;
        
    case "sq_speed":
            obj_demo.sq_speed = arg[0];
        break;

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw console

// Console visible
if (con_visible) {

    // Background surface
    if (surface_exists(con_surf)) {
        draw_surface(con_surf,0,0);
    }
    
    // Dim screen
    draw_set_alpha(con_dim);
    draw_set_color(c_black);
    var sw = surface_get_width(con_surf);
    var sh = surface_get_height(con_surf);
    draw_rectangle(0,0,sw,sh,false);

    // Fill
    draw_set_alpha(fill_a);
    draw_set_color(fill_c);
    draw_rectangle(textbox_x,textbox_y,textbox_x+width,textbox_y+height, false);
    
    if (!active) {
    
        // Border
        draw_set_alpha(border_a);
        draw_set_color(border_c);
        draw_rectangle_width(textbox_x, textbox_y, textbox_x+width, textbox_y+height, border_w);
        
    } else {
    
        // Active border
        draw_set_alpha(active_a);
        draw_set_colour(active_c);
        draw_rectangle_width(textbox_x, textbox_y, textbox_x+width, textbox_y+height, active_w);
    
    }
    
    // Text area size
    var x1 = textbox_x+padding;
    var y1 = textbox_y+padding;
    var x2 = (textbox_x+width)-padding;
    
    // Textbox surface
    surface_set_target(surf);
        
        // Ready surface for drawing
        draw_clear_alpha(c_black, 0);
        
        // Draw text
        draw_set_alpha(fnt_a);
        draw_set_color(fnt_c);
        draw_set_font(fnt);
        draw_text(-scroll, 0, value);
        
        // If textbox active
        if (active) {
        
            // Highlighting
            if (cursor_pos1 != cursor_pos2) {
            
                // Size
                var minpos = min(cursor_pos1, cursor_pos2);
                var maxpos = max(cursor_pos1, cursor_pos2);
                var curx1 = string_width(string_copy(value, 0, minpos))-scroll;
                var curx2 = string_width(string_copy(value, 0, maxpos))-scroll;
            
                // Background
                draw_set_alpha(select_bg_a);
                draw_set_color(select_bg_c);
                draw_rectangle(curx1, 0, curx2, string_height("Wp"), 0);
                
                // Text
                var sel = string_copy(value, minpos+1, (maxpos-minpos));
                
                draw_set_alpha(select_fnt_a);
                draw_set_color(select_fnt_c);
                draw_text(curx1, 0, sel);
            
            }
            
        }
        
    surface_reset_target();
    
    // Cursor
    if (active &amp;&amp; cursor_pos1 = cursor_pos2 &amp;&amp; cursor_flash) {
        
        var curx = clamp(x1+string_width(string_copy(value, 0, cursor_pos1))-scroll, x1, x2);
        
        draw_set_alpha(cursor_a);
        draw_set_color(cursor_c);
        draw_line_width(curx, y1, curx, y1+string_height("Wp"), cursor_w);
        
    }
    
    // Draw textbox surface
    draw_surface(surf, x1, y1);
    draw_set_alpha(1);
    
    // Suggestions
    if (con_sug_enabled &amp;&amp; !ds_list_empty(con_sug)) {
    
        // Position
        var sx = textbox_x + con_sug_pad;
        var sy = textbox_y + height; 
        var lh = string_height("Wp");
        
        // Suggestions
        for (var i=0;i&lt;ds_list_size(con_sug);i++) {
        
            // Get command
            var index = con_sug[| i];
            var cmd = con_cmds[| index];
            var args = con_cmds[| index+2];
            var typs = con_cmds[| index+3];
            
            // Background
            if (con_sug_sel == i) then
            draw_set_color(con_sug_sel_c) else
            draw_set_color(con_sug_bg_c);
            draw_rectangle(textbox_x-border_w,sy,textbox_x+width,sy+lh+(con_sug_pad*2),false);
            
            // Command
            draw_set_color(con_sug_cmd_c);
            draw_set_halign(fa_left);
            draw_set_valign(fa_top);
            
            if (is_array(args)) then cmd += con_sep;
            draw_text(sx,sy+con_sug_pad,cmd);
            
            // Arguments
            if (is_array(args)) {
            
                // Position
                sx += string_width(cmd);
            
                // For each argument
                for (a=0; a&lt;array_length_1d(args); a++) {
                
                    draw_set_color(con_sug_arg_c);
                    draw_text(sx,sy+con_sug_pad,args[a]);
                    sx += string_width(args[a]);
                
                    // Check if type is set
                    if (is_array(typs) &amp;&amp; !is_undefined(typs[a])) {
                    
                        draw_set_color(con_sug_typ_c);
                        var typ = "["+typs[a]+"]";
                        draw_text(sx,sy+con_sug_pad,typ);
                        sx += string_width(typ);
                    
                    }
                    
                    draw_set_color(con_sug_arg_c);
                    draw_text(sx,sy+con_sug_pad,con_sep);
                    sx += string_width(con_sep);
                
                }
            
            }
            
            // Next row
            sx = textbox_x + con_sug_pad;
            sy += lh+(con_sug_pad*2);
        
        }
    
    }
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
